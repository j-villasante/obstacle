{"version":3,"sources":["node_modules/browser-pack/_prelude.js","static/src/Ball.js","static/src/BallController.js","static/src/app.js","static/src/utils/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","class Ball {\n    constructor (context, x, y, r) {\n        this.x = x\n        this.y = y\n        this.radius = r\n        this.color = this.getRandomColor()\n        this.ctx = context\n    }\n\n    getRandomColor () {\n        return '#000000'.replace(/0/g, () => (~~(Math.random() * 16)).toString(16))\n    }\n\n    setSpeed (vx, vy) {\n        this.vx = vx\n        this.vy = vy\n    }\n\n    setPosition (x, y) {\n        this.x = x\n        this.y = y\n    }\n\n    move () {\n        this.x += this.vx\n        this.y += this.vy\n    }\n\n    draw () {\n        this.ctx.beginPath()\n        this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true)\n        this.ctx.closePath()\n        this.ctx.fillStyle = this.color\n        this.ctx.fill()\n    }\n}\n\nmodule.exports = Ball\n","const Ball = require('./Ball.js')\nconst utils = require('./utils')\n\nclass BallController {\n    constructor (context, canvas) {\n        this.ctx = context\n        this.canvas = canvas\n        this.balls = []\n    }\n\n    addBall (quantity = 1) {\n        let i = 0\n        while (i < quantity) {\n            let randRadius = utils.getRandomInt(10, 25)\n            let randomX = utils.getRandomInt(0 + randRadius, this.canvas.width - randRadius)\n            let randomY = utils.getRandomInt(0 + randRadius, this.canvas.height - randRadius)\n            let randSpeedX = utils.getRandomInt(3, 8)\n            let randSpeedY = utils.getRandomInt(3, 8)\n            let ball = new Ball(this.ctx, randomX, randomY, randRadius)\n            ball.setSpeed(randSpeedX, randSpeedY)\n            this.balls.push(ball)\n            i++\n        }\n    }\n\n    moveBalls () {\n        for (let ball of this.balls) {\n            if (ball.y + ball.vy + ball.radius > this.canvas.height || ball.y + ball.vy - ball.radius < 0) {\n                ball.vy = -ball.vy\n            }\n\n            if (ball.x + ball.vx + ball.radius > this.canvas.width || ball.x + ball.vx - ball.radius < 0) {\n                ball.vx = -ball.vx\n            }\n            ball.move()\n        }\n    }\n\n    createStaticBall () {\n        this.staticBall = new Ball(this.ctx, 25, 25, 15)\n    }\n\n    moveBallOnMouseMove (e) {\n        let rect = this.canvas.getBoundingClientRect()\n        this.staticBall.setPosition(e.clientX - rect.left, e.clientY - rect.top)\n    }\n\n    render () {\n        for (let ball of this.balls) {\n            ball.draw()\n        }\n        this.staticBall.draw()\n    }\n}\n\nmodule.exports = BallController\n","const BallController = require('./BallController.js')\n\nclass Main {\n    constructor () {\n        this.canvas = document.getElementById('canvas')\n        this.spanBalls = document.getElementById('span-balls')\n        this.ctx = this.canvas.getContext('2d')\n        this.ballCount = 3\n        this.increment = 1\n    }\n\n    setNewBallsController () {\n        this.controller = new BallController(this.ctx, this.canvas)\n    }\n\n    animate () {\n        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n        this.controller.moveBalls()\n        this.controller.render()\n        window.requestAnimationFrame(() => this.animate())\n    }\n\n    start () {\n        this.controller.addBall(this.ballCount)\n        this.controller.createStaticBall()\n        this.animate(this.controller)\n        setInterval(() => {\n            this.controller.addBall(this.increment)\n            this.ballCount += this.increment\n            this.spanBalls.innerHTML = this.ballCount\n            this.increment++\n        }, 10000)\n        this.canvas.addEventListener('mousemove', e => this.controller.moveBallOnMouseMove(e))\n    }\n}\n\nlet main = new Main()\nmain.setNewBallsController()\nmain.start()\n","class Utils {\n    /**\n     * Returns a random number between min (inclusive) and max (exclusive)\n     */\n    getRandomArbitrary (min, max) {\n        return Math.random() * (max - min) + min\n    }\n\n    /**\n     * Returns a random integer between min (inclusive) and max (inclusive)\n     * Using Math.round() will give you a non-uniform distribution!\n     */\n    getRandomInt (min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min\n    }\n}\n\nmodule.exports = new Utils()\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzdGF0aWMvc3JjL0JhbGwuanMiLCJzdGF0aWMvc3JjL0JhbGxDb250cm9sbGVyLmpzIiwic3RhdGljL3NyYy9hcHAuanMiLCJzdGF0aWMvc3JjL3V0aWxzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImNsYXNzIEJhbGwge1xuICAgIGNvbnN0cnVjdG9yIChjb250ZXh0LCB4LCB5LCByKSB7XG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgdGhpcy55ID0geVxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJcbiAgICAgICAgdGhpcy5jb2xvciA9IHRoaXMuZ2V0UmFuZG9tQ29sb3IoKVxuICAgICAgICB0aGlzLmN0eCA9IGNvbnRleHRcbiAgICB9XG5cbiAgICBnZXRSYW5kb21Db2xvciAoKSB7XG4gICAgICAgIHJldHVybiAnIzAwMDAwMCcucmVwbGFjZSgvMC9nLCAoKSA9PiAofn4oTWF0aC5yYW5kb20oKSAqIDE2KSkudG9TdHJpbmcoMTYpKVxuICAgIH1cblxuICAgIHNldFNwZWVkICh2eCwgdnkpIHtcbiAgICAgICAgdGhpcy52eCA9IHZ4XG4gICAgICAgIHRoaXMudnkgPSB2eVxuICAgIH1cblxuICAgIHNldFBvc2l0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgdGhpcy55ID0geVxuICAgIH1cblxuICAgIG1vdmUgKCkge1xuICAgICAgICB0aGlzLnggKz0gdGhpcy52eFxuICAgICAgICB0aGlzLnkgKz0gdGhpcy52eVxuICAgIH1cblxuICAgIGRyYXcgKCkge1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICB0aGlzLmN0eC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSlcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvclxuICAgICAgICB0aGlzLmN0eC5maWxsKClcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFsbFxuIiwiY29uc3QgQmFsbCA9IHJlcXVpcmUoJy4vQmFsbC5qcycpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jbGFzcyBCYWxsQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IgKGNvbnRleHQsIGNhbnZhcykge1xuICAgICAgICB0aGlzLmN0eCA9IGNvbnRleHRcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXNcbiAgICAgICAgdGhpcy5iYWxscyA9IFtdXG4gICAgfVxuXG4gICAgYWRkQmFsbCAocXVhbnRpdHkgPSAxKSB7XG4gICAgICAgIGxldCBpID0gMFxuICAgICAgICB3aGlsZSAoaSA8IHF1YW50aXR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZFJhZGl1cyA9IHV0aWxzLmdldFJhbmRvbUludCgxMCwgMjUpXG4gICAgICAgICAgICBsZXQgcmFuZG9tWCA9IHV0aWxzLmdldFJhbmRvbUludCgwICsgcmFuZFJhZGl1cywgdGhpcy5jYW52YXMud2lkdGggLSByYW5kUmFkaXVzKVxuICAgICAgICAgICAgbGV0IHJhbmRvbVkgPSB1dGlscy5nZXRSYW5kb21JbnQoMCArIHJhbmRSYWRpdXMsIHRoaXMuY2FudmFzLmhlaWdodCAtIHJhbmRSYWRpdXMpXG4gICAgICAgICAgICBsZXQgcmFuZFNwZWVkWCA9IHV0aWxzLmdldFJhbmRvbUludCgzLCA4KVxuICAgICAgICAgICAgbGV0IHJhbmRTcGVlZFkgPSB1dGlscy5nZXRSYW5kb21JbnQoMywgOClcbiAgICAgICAgICAgIGxldCBiYWxsID0gbmV3IEJhbGwodGhpcy5jdHgsIHJhbmRvbVgsIHJhbmRvbVksIHJhbmRSYWRpdXMpXG4gICAgICAgICAgICBiYWxsLnNldFNwZWVkKHJhbmRTcGVlZFgsIHJhbmRTcGVlZFkpXG4gICAgICAgICAgICB0aGlzLmJhbGxzLnB1c2goYmFsbClcbiAgICAgICAgICAgIGkrK1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZUJhbGxzICgpIHtcbiAgICAgICAgZm9yIChsZXQgYmFsbCBvZiB0aGlzLmJhbGxzKSB7XG4gICAgICAgICAgICBpZiAoYmFsbC55ICsgYmFsbC52eSArIGJhbGwucmFkaXVzID4gdGhpcy5jYW52YXMuaGVpZ2h0IHx8IGJhbGwueSArIGJhbGwudnkgLSBiYWxsLnJhZGl1cyA8IDApIHtcbiAgICAgICAgICAgICAgICBiYWxsLnZ5ID0gLWJhbGwudnlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJhbGwueCArIGJhbGwudnggKyBiYWxsLnJhZGl1cyA+IHRoaXMuY2FudmFzLndpZHRoIHx8IGJhbGwueCArIGJhbGwudnggLSBiYWxsLnJhZGl1cyA8IDApIHtcbiAgICAgICAgICAgICAgICBiYWxsLnZ4ID0gLWJhbGwudnhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhbGwubW92ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVTdGF0aWNCYWxsICgpIHtcbiAgICAgICAgdGhpcy5zdGF0aWNCYWxsID0gbmV3IEJhbGwodGhpcy5jdHgsIDI1LCAyNSwgMTUpXG4gICAgfVxuXG4gICAgbW92ZUJhbGxPbk1vdXNlTW92ZSAoZSkge1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIHRoaXMuc3RhdGljQmFsbC5zZXRQb3NpdGlvbihlLmNsaWVudFggLSByZWN0LmxlZnQsIGUuY2xpZW50WSAtIHJlY3QudG9wKVxuICAgIH1cblxuICAgIHJlbmRlciAoKSB7XG4gICAgICAgIGZvciAobGV0IGJhbGwgb2YgdGhpcy5iYWxscykge1xuICAgICAgICAgICAgYmFsbC5kcmF3KClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRpY0JhbGwuZHJhdygpXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGxDb250cm9sbGVyXG4iLCJjb25zdCBCYWxsQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vQmFsbENvbnRyb2xsZXIuanMnKVxuXG5jbGFzcyBNYWluIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpXG4gICAgICAgIHRoaXMuc3BhbkJhbGxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwYW4tYmFsbHMnKVxuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgdGhpcy5iYWxsQ291bnQgPSAzXG4gICAgICAgIHRoaXMuaW5jcmVtZW50ID0gMVxuICAgIH1cblxuICAgIHNldE5ld0JhbGxzQ29udHJvbGxlciAoKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBCYWxsQ29udHJvbGxlcih0aGlzLmN0eCwgdGhpcy5jYW52YXMpXG4gICAgfVxuXG4gICAgYW5pbWF0ZSAoKSB7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNiknXG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgICAgIHRoaXMuY29udHJvbGxlci5tb3ZlQmFsbHMoKVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIucmVuZGVyKClcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGUoKSlcbiAgICB9XG5cbiAgICBzdGFydCAoKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hZGRCYWxsKHRoaXMuYmFsbENvdW50KVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuY3JlYXRlU3RhdGljQmFsbCgpXG4gICAgICAgIHRoaXMuYW5pbWF0ZSh0aGlzLmNvbnRyb2xsZXIpXG4gICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hZGRCYWxsKHRoaXMuaW5jcmVtZW50KVxuICAgICAgICAgICAgdGhpcy5iYWxsQ291bnQgKz0gdGhpcy5pbmNyZW1lbnRcbiAgICAgICAgICAgIHRoaXMuc3BhbkJhbGxzLmlubmVySFRNTCA9IHRoaXMuYmFsbENvdW50XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCsrXG4gICAgICAgIH0sIDEwMDAwKVxuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlID0+IHRoaXMuY29udHJvbGxlci5tb3ZlQmFsbE9uTW91c2VNb3ZlKGUpKVxuICAgIH1cbn1cblxubGV0IG1haW4gPSBuZXcgTWFpbigpXG5tYWluLnNldE5ld0JhbGxzQ29udHJvbGxlcigpXG5tYWluLnN0YXJ0KClcbiIsImNsYXNzIFV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChleGNsdXNpdmUpXG4gICAgICovXG4gICAgZ2V0UmFuZG9tQXJiaXRyYXJ5IChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGluY2x1c2l2ZSlcbiAgICAgKiBVc2luZyBNYXRoLnJvdW5kKCkgd2lsbCBnaXZlIHlvdSBhIG5vbi11bmlmb3JtIGRpc3RyaWJ1dGlvbiFcbiAgICAgKi9cbiAgICBnZXRSYW5kb21JbnQgKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBVdGlscygpXG4iXX0="}